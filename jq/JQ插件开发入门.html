<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JQ插件开发入门</title>
	<script src="http://www1.pcbaby.com.cn/test/lib/jquery1.10.2.min.js"></script>
</head>
<body>
	<p class="test">JQ插件开发入门</p>
	<div><a href="https://thinkerchan.com/">link</a></div>
	<div><a href="https://thinkerchan.com/">link</a></div>
	<div><a href="https://thinkerchan.com/">link</a></div>
	<script>
	//test0
	// alert($.fn==jQuery.fn);
	// alert(jQuery.fn==jQuery.prototype);
	// alert($.fn==jQuery.prototype);
	// alert($.fn==$.prototype);
	//以上都返回true

	//test1 第一种扩展方式
	// $.extend({
	// 	sayHello:function(str){
	// 		console.log('hello:'+(str?str:'k')+'!');
	// 	}
	// });
	// $.sayHello();
	// $.sayHello('陈新垲');


	//test2	 语法:$.extend(true, target object, object1);
	// var temp = $.extend({
	//     log: function(str) {
	//         var now = new Date(),
	//             y = now.getFullYear(),
	//             m = now.getMonth() + 1, //！JavaScript中月分是从0开始的
	//             d = now.getDate(),
	//             h = now.getHours(),
	//             min = now.getMinutes(),
	//             s = now.getSeconds(),
	//             time = y + '/' + m + '/' + d + ' ' + h + ':' + min + ':' + s;
	//         console.log(time + str);
	//     }
	// })
	// temp.log('test...');
	// $.log('test...');		//可以这样调用是因为log所存在的对象 保存在了$环境中.

	//test3 第二种扩展方式
	// $.fn.myplugin=function(){
	// 	// this.css('color', 'red');	//this是选中的那个jqery元素
	// 	this.css('color', 'red');
	//  this.each(function() {	//遍历这个jquery节点内的每个DOM元素
	//       //对每个元素添加子节点 在这里是文本节点
	//       $(this).append(' ' + $(this).attr('href'));
	//  	});
	// }
	// $('a').myplugin();	//用a元素做测试
	//由于每一个jq元素都返回了自身,所以当在写扩展插件的时候,如果要保持链式调用,就要记得给扩展插件return this;

	//test3*
	//只需要改写成这样
	// $.fn.myplugin = function() {
	//     this.css('color', 'red');
	//     return this.each(function() {		//加上return语句
	//         $(this).append(' ' + $(this).attr('href'));
	//     }))
	// }

	//test4 $.extend方法 , 将多个对象合并到第一个对象
	// var o1 = {p1:['a','b']};
	// var o2 = $.extend({},o1);
	// var o3 = $.extend(true,{},o1);
	// o1.p1[0]='c';
	// console.log(o2.p1);	//覆盖了p1[0];说明extend没有true参数时,改变的是一份拷贝
	// o2.p1 // ["c", "b"]
	// console.log(o3.p1);
	// o3.p1 // ["a", "b"]

	//test5
	// $.fn.myplugin = function(options) {
	//    var defaults = {
	//      'color': 'blue',
	//      'fontSize': '12px'
	//    };
	//    var settings = $.extend(defaults, options);	//$.extend()方法用于重写对象, 但是这里还是会有问题
	//    console.log(defaults);	//defaults在传入options的时候就被重写了.
	//    return this.css({
	//      'color': settings.color,
	//      'fontSize': settings.fontSize
	//    });
	// }
	// $('a').myplugin({
	// 	'color':'green',
	// 	'fontSize':'20px'
	// });

	//test5* 上面的$.extend()用起来似乎没问题,但实际上 defaults一旦被重写,就会丢失原来的值
	// $.fn.myplugin = function(options) {
	//    var defaults = {
	//      'color': 'blue',
	//      'fontSize': '12px'
	//    };
	//    var settings = $.extend({},defaults, options);	//所以传了一个空对象,用于保护defaults. perfect!
	//    console.log(defaults);	//被保留了下来, 因此写插件的时候要注意到健壮性
	//    return this.css({
	//      'color': settings.color,
	//      'fontSize': settings.fontSize
	//    });
	// }
	// $('a').myplugin({
	// 	'color':'green',
	// 	'fontSize':'20px'
	// });

	//test6 面向对象封装 , 我们来定义一个Beautifier构造函数,体会一下面向对象编程.
	// var Beautifier = function(ele, opt) {
	//     this.$element = ele,	//接受JQ元素,作为一个属性存起来.
	//     this.defaults = {
	//         'color': 'red',
	//         'fontSize': '12px',
	//         'textDecoration':'none'
	//     },
	//     this.options = $.extend({}, this.defaults, opt)
	//     // console.log(this);	//this是构造函数实例
	// }
	// Beautifier.prototype = {
	//     beautify: function() {
	//         return this.$element.css({	//注意这里的return是用来返回JQ对象
	//             'color': this.options.color,
	//             'fontSize': this.options.fontSize,
	//             'textDecoration': this.options.textDecoration
	//         });
	//     }
	// }
	// $.fn.myplugin = function(options) {
	//     // console.log(this);	//JQ元素
	//     var beautifier = new Beautifier(this, options);	//体会一下这里的this, 将JQ元素传递进去
	//     return beautifier.beautify();
	// }
	// $('a').myplugin({
	// 	'color':'#999',
	// 	'fontSize': '22px',
	//   'textDecoration':'none'
	// })

	//test7 命名空间的优化
	//前一个test中我们将Beautifier直接暴露在全局,这样很可能在引入其他库的时候发生变量冲突,因此用匿名函数存放并立即执行,保证不会发生污染
	// ;(function(){		//注意这里加了一个分号,避免压缩的时候出现问题.
	// 	var Beautifier = function(ele, opt) {
	// 	    this.$element = ele,	//接受JQ元素,作为一个属性存起来.
	// 	    this.defaults = {
	// 	        'color': 'red',
	// 	        'fontSize': '12px',
	// 	        'textDecoration':'none'
	// 	    },
	// 	    this.options = $.extend({}, this.defaults, opt)
	// 	    // console.log(this);	//this是构造函数实例
	// 	}
	// 	Beautifier.prototype = {
	// 	    beautify: function() {
	// 	        return this.$element.css({	//注意这里的return是用来返回JQ对象
	// 	            'color': this.options.color,
	// 	            'fontSize': this.options.fontSize,
	// 	            'textDecoration': this.options.textDecoration
	// 	        });
	// 	    }
	// 	}
	// 	$.fn.myplugin = function(options) {
	// 	    // console.log(this);	//JQ元素
	// 	    var beautifier = new Beautifier(this, options);	//体会一下这里的this, 将JQ元素传递进去
	// 	    return beautifier.beautify();
	// 	}
	// 	$('a').myplugin({
	// 		'color':'blue',
	// 		'fontSize': '22px',
	// 	  'textDecoration':'none'
	// 	})
	// })();

	//test8 改良立即执行函数的参数传递
	// ;(function($,window,document,undefined){
	// 	//之所以把这些系统变量传递进来,是以防我们在编写代码时用到,虽然在内也能直接使用全局变量,但是预先传递进来,能提高访问速度,于是性能也相应提升
	// 	//undefined, 这个东西非常妙,我们没有传递,但是却在接收端上写上了它. 我的理解类似前面, 变量在作用域链中如果没有找到本应该找到的值,就会一直向上查找,知道undefined, 此处缓存可以加快访问进度.
	// 	var Beautifier = function(ele, opt) {
	// 	    this.$element = ele,	//接受JQ元素,作为一个属性存起来.
	// 	    this.defaults = {
	// 	        'color': 'red',
	// 	        'fontSize': '12px',
	// 	        'textDecoration':'none'
	// 	    },
	// 	    this.options = $.extend({}, this.defaults, opt)
	// 	    // console.log(this);	//this是构造函数实例
	// 	}
	// 	Beautifier.prototype = {
	// 	    beautify: function() {
	// 	        return this.$element.css({	//注意这里的return是用来返回JQ对象
	// 	            'color': this.options.color,
	// 	            'fontSize': this.options.fontSize,
	// 	            'textDecoration': this.options.textDecoration
	// 	        });
	// 	    }
	// 	}
	// 	$.fn.myplugin = function(options) {
	// 	    // console.log(this);	//JQ元素
	// 	    var beautifier = new Beautifier(this, options);	//体会一下这里的this, 将JQ元素传递进去
	// 	    return beautifier.beautify();
	// 	}
	// 	$('a').myplugin({
	// 		'color':'blue',
	// 		'fontSize': '22px',
	// 	  'textDecoration':'none'
	// 	})
	// })($,window,document);
	</script>
</body>
</html>